// Copyright Â© 2023 Sven Moog, Niklas Siemer
//
// This file is part of qFALL-crypto.
//
// qFALL-crypto is free software: you can redistribute it and/or modify it under
// the terms of the Mozilla Public License Version 2.0 as published by the
// Mozilla Foundation. See <https://mozilla.org/en-US/MPL/2.0/>.

use crate::SizeN;
use criterion::*;
use performed_functions::*;

/// This module contains all values and functions loading or storing precomputed values.
pub(super) mod load_precomputed_values {
    use crate::SizeN;
    use qfall_crypto::construction::pk_encryption::Regev;
    use qfall_math::integer_mod_q::MatZq;

    // The pre-computed values were computed with the following code:
    //
    // let scheme = Regev::new(50, 816, 63853, 0.0022); // Regev::default();
    // let (pk, sk) = scheme.gen();
    // let message = 1;
    // let cipher = scheme.enc(&pk, message);
    // println!("PK: {}", serde_json::to_string(&pk).unwrap());
    // println!("SK: {}", serde_json::to_string(&sk).unwrap());
    // println!("C: {}", serde_json::to_string(&cipher).unwrap());

    /// This was previously generated by [`RingLPR::gen`]
    /// with the parameters set in [`RingLPR::new(50, 816, 63853, 0.0022)`].
    const LARGE_SK: &str = "{\"matrix\":\"[[52659],[16027],[6007],[36789],[60152],[9883],[53461],[60227],[61976],[39903],[13305],[9113],[18359],[58339],[23569],[12134],[4093],[57317],[50556],[59354],[36834],[57205],[62803],[60133],[29607],[46003],[41370],[34748],[24902],[19114],[50123],[14970],[39280],[52548],[49670],[62594],[16862],[51392],[22326],[21499],[29163],[14209],[38782],[44784],[28005],[23555],[14917],[34087],[2002],[3415]] mod 63853\"}";
    const LARGE_CIPHER: &str = "{\"matrix\":\"[[8217],[34299],[40589],[52866],[18729],[63537],[31149],[143],[52023],[9252],[2047],[16823],[54463],[20826],[61624],[47483],[41211],[47843],[57770],[7319],[4100],[51121],[16545],[58379],[51239],[32600],[21285],[35983],[26200],[16191],[18481],[23863],[6706],[38408],[53652],[30524],[41628],[45034],[19655],[28956],[54435],[50519],[58796],[31513],[22473],[2600],[42225],[17478],[55756],[35616],[57541]] mod 63853\"}";

    /// This was previously generated by [`RingLPR::gen`]
    /// with the parameters set in [`RingLPR::default`].
    const SMALL_SK: &str = "{\"matrix\":\"[[793],[1073],[642],[214],[1108],[141],[821],[22],[47],[164],[1199],[1139],[818]] mod 1427\"}";
    const SMALL_CIPHER: &str = "{\"matrix\":\"[[1061],[642],[146],[220],[1342],[1386],[1070],[740],[633],[133],[1136],[1159],[1111],[840]] mod 1427\"}";

    /// Loads one of the above precomputed public key suitable to:
    /// - [`SizeN::Small`]: [`Regev::default`]
    /// - [`SizeN::Large`]: [`Regev::new()`]
    pub(super) fn load_precomputed_pk(size_n: &SizeN) -> MatZq {
        let pk: MatZq = if size_n == &SizeN::Large {
            serde_json::from_str(std::fs::read_to_string("benches/pk_encryption/large_precomputed_values/regev_large_pk.txt").unwrap().as_str()).unwrap()
        } else {
            serde_json::from_str(std::fs::read_to_string("benches/pk_encryption/large_precomputed_values/regev_small_pk.txt").unwrap().as_str()).unwrap()
        };

        pk
    }

    /// Loads one of the above precomputed secret key suitable to:
    /// - [`SizeN::Small`]: [`Regev::default`]
    /// - [`SizeN::Large`]: [`Regev::new()`]
    pub(super) fn load_precomputed_sk(size_n: &SizeN) -> MatZq {
        let sk: MatZq = if size_n == &SizeN::Large {
            serde_json::from_str(LARGE_SK).unwrap()
        } else {
            serde_json::from_str(SMALL_SK).unwrap()
        };

        sk
    }

    /// Loads one of the above precomputed ciphers suitable to:
    /// - [`SizeN::Small`]: [`Regev::default`]
    /// - [`SizeN::Large`]: [`Regev::new()`]
    pub(super) fn load_precomputed_cipher(size_n: &SizeN) -> MatZq {
        let cipher: MatZq = if size_n == &SizeN::Large {
            serde_json::from_str(LARGE_CIPHER).unwrap()
        } else {
            serde_json::from_str(SMALL_CIPHER).unwrap()
        };

        cipher
    }

    /// Loads one of the above precomputed variants suitable to:
    /// - [`SizeN::Small`]: [`Regev::default`]
    /// - [`SizeN::Large`]: [`Regev::new()`]
    pub(super) fn load_suiting_regev(size_n: &SizeN) -> Regev {
        if size_n == &SizeN::Large {
            Regev::new(50, 816, 63853, 0.0022)
        } else {
            Regev::default()
        }
    }
}

/// This module contains all functions directly executed in the benchmarking functions.
pub(super) mod performed_functions {
    use super::load_precomputed_values::*;
    use crate::SizeN;
    use qfall_crypto::construction::pk_encryption::PKEncryptionScheme;
    use qfall_crypto::construction::pk_encryption::Regev;
    use qfall_math::integer::Z;

    /// Performs a full-cycle of gen, enc, dec with [`Regev`].
    pub(super) fn regev_full_cycle(n: i64) {
        let msg = Z::ONE;
        let regev = Regev::new_from_n(n);

        let (pk, sk) = regev.gen();
        let cipher = regev.enc(&pk, &msg);
        let _ = regev.dec(&sk, &cipher);
    }

    /// Performs a cycle of `enc` and `dec` with precomputed [`Regev`] parameters.
    pub(super) fn regev_cycle(size_n: &SizeN) {
        let msg = Z::ONE;
        let regev = load_suiting_regev(size_n);

        let pk = load_precomputed_pk(size_n);
        let sk = load_precomputed_sk(size_n);
        let cipher = regev.enc(&pk, &msg);
        let _ = regev.dec(&sk, &cipher);
    }

    /// Performs a cycle of `enc` with precomputed [`Regev`] parameters and keys.
    pub(super) fn regev_enc(size_n: &SizeN) {
        let msg = Z::ONE;
        let regev = load_suiting_regev(size_n);
        let pk = load_precomputed_pk(size_n);

        let _ = regev.enc(&pk, &msg);
    }

    /// Performs a cycle of `dec` with precomputed [`Regev`] parameters and keys.
    pub(super) fn regev_dec(size_n: &SizeN) {
        let regev = load_suiting_regev(size_n);
        let sk = load_precomputed_sk(size_n);
        let cipher = load_precomputed_cipher(size_n);

        let _ = regev.dec(&sk, &cipher);
    }
}

/// Benchmark [regev_cycle] with `n = 10, 20, 30, 40, 50, 60`
///
/// This benchmark can be run with for example:
/// - `cargo criterion "Regev\ n\ sweep"`
/// - `cargo criterion Regev\ n\ sweep/n=20` (only run the n=20 benchmark).
/// - `cargo criterion 'Regev.*n=20'` (only run the n=20 benchmark).
/// - `cargo bench --bench benchmarks Regev\ n\ sweep`
///
/// Shorter variants or regex expressions can also be used to specify the
/// benchmark name. The `\ ` is used to escape the space, alternatively,
/// quotation marks can be used.
fn bench_regev_cycle_n_sweep(c: &mut Criterion) {
    let mut group = c.benchmark_group("Regev n sweep");

    for n in [10, 20, 30, 40, 50, 60].iter() {
        group.bench_function(format!("n={n}"), |b| b.iter(|| regev_full_cycle(*n)));
    }

    group.finish();
}

/// Benchmark [regev_full_cycle] with `n = 50`.
///
/// This benchmark can be run with for example:
/// - `cargo criterion Regev\ n=50`
/// - `cargo bench --bench benchmarks Regev\ n=50`
/// - `cargo flamegraph --bench benchmarks -- --bench Regev\ n=50`
///
/// Shorter variants or regex expressions can also be used to specify the
/// benchmark name. The `\ ` is used to escape the space, alternatively,
/// quotation marks can be used.
fn bench_regev_large_full_cycle(c: &mut Criterion) {
    c.bench_function("Regev n=50 gen enc dec", |b| {
        b.iter(|| regev_full_cycle(50))
    });
}

/// Benchmark [regev_cycle] with `n = 50` and precomputed keys.
fn bench_regev_large_cycle(c: &mut Criterion) {
    c.bench_function("Regev n=50 enc dec", |b| {
        b.iter(|| regev_cycle(&SizeN::Large))
    });
}

/// Benchmark [regev_enc] with `n = 50` and precomputed keys.
fn bench_regev_large_enc(c: &mut Criterion) {
    c.bench_function("Regev n=50 enc", |b| b.iter(|| regev_enc(&SizeN::Large)));
}

/// Benchmark [regev_dec] with `n = 50` and precomputed keys.
fn bench_regev_large_dec(c: &mut Criterion) {
    c.bench_function("Regev n=50 dec", |b| b.iter(|| regev_dec(&SizeN::Large)));
}

/// Benchmark [regev_full_cycle] with `n = 13`.
fn bench_regev_small_full_cycle(c: &mut Criterion) {
    c.bench_function("Regev n=13 gen enc dec", |b| {
        b.iter(|| regev_full_cycle(13))
    });
}

/// Benchmark [regev_cycle] with `n = 13` and precomputed keys.
fn bench_regev_small_cycle(c: &mut Criterion) {
    c.bench_function("Regev n=13 enc dec", |b| {
        b.iter(|| regev_cycle(&SizeN::Small))
    });
}

/// Benchmark [regev_enc] with `n = 13` and precomputed keys.
fn bench_regev_small_enc(c: &mut Criterion) {
    c.bench_function("Regev n=13 enc", |b| b.iter(|| regev_enc(&SizeN::Small)));
}

/// Benchmark [regev_dec] with `n = 13` and precomputed keys.
fn bench_regev_small_dec(c: &mut Criterion) {
    c.bench_function("Regev n=13 dec", |b| b.iter(|| regev_dec(&SizeN::Small)));
}

criterion_group!(
    benches,
    bench_regev_cycle_n_sweep,
    bench_regev_large_full_cycle,
    bench_regev_large_cycle,
    bench_regev_large_enc,
    bench_regev_large_dec,
    bench_regev_small_full_cycle,
    bench_regev_small_cycle,
    bench_regev_small_enc,
    bench_regev_small_dec,
);
